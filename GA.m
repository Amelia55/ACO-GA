% 旅行商人要拜访12个省会城市，每个城市只拜访一次，最终要回到原来的出发城市，
% 所选路径为所有路径之中的最小值
clear all;
close all;
clc;
%% 导入数据
citys = [2 5 91;3 6 85;4 7 55;5 8 45;7 9 25;9 10 70;...
   11 11 92; 20 12 95;29 13 94;31 14 71;35 15 50;0 0 0];
% citys = [716180.123,3530673.308,70.011;716180.123,3530674.20000214,60.412;716180.123,3530675.308,50.819;716180.123,3530676.20000214,43.360;...
%      716180.123,3530677.308,40.849; 716180.123,3530678.20000214,64.954;716180.123,3530679.308,73.021;716177.123,3530694.20000214,64.747;...
%      716180.123,3530726.308,65.015;716180.123,3530727.654,55.729;716180.123,3530725.225,73.021;716160.1500,3530717.1500,34.9300;716182.0900,3530708.3000,28.4500;...
%      716192.0000,3530686.0800,27.8600;716209.9100,3530674.9000,28.8100;716186.2700,3530691.1000,40.0300;716178.2000,3530697.2500,45.9300;716154.5700,3530702.4800,59.6700;...
%      716222.0400,3530713.8700,58.0700;
% 716152.9700,3530700.5800,69.2900;
% 716180.0600,3530698.5800,67.8300;
% 716183.2300,3530685.0900,71.9000;
% 716184.0600,3530683.7200,67.0500;
% 716182.0100,3530682.5900,62.2300;
% 716219.4200,3530701.3700,58.4000;
% 716210.2500,3530687.8300,59.5200;
% 716172.2600,3530666.6400,28.0900;
% 716224.5600,3530691.8400,67.9800;
% 716152.7400,3530692.1500,31.8200;
% 716224.3100,3530722.9900,29.7200;
% 716152.7900,3530720.5700,38.5400;
% 716176.4600,3530689.7900,30.1200;
% 716183.0900,3530694.4300,53.6400;
% 716216.2800,3530693.2400,28.6400];
%  V_LAND =8; %地速，起飞前为无人机设定的速度
%  POWER = 160;
%% TSP 问题的规模，即城市数目
n = size(citys,1);%N表示染色体基因维数
D = zeros(n);%任意两个城市距离间隔矩阵

%% 求任意两个城市距离间隔矩阵
for i = 1:n
    for j = 1:n
        if i ~= j
        		D(i,j) = sqrt(sum((citys(i,1)-citys(j,1)).^2)+(citys(i,2)-citys(j,2)).^2+(citys(i,3)-citys(j,3)).^2);
        else
            D(i,j) = 1e-4;      
        end
    end    
end
NP = 100; %种群规模
G = 500; %最大遗传代数
f = zeros(NP,n); %用于存储种群
F = []; %种群更新中间存储
for i = 1 :NP
    f(i,1) = n;
    f(i,2:end) = randperm(n-1); %随机生成初始种群；randperm随机生成1-N的整数
end
R = f(1,:);%存储最优种群
len = zeros(NP,1);%存储路径长度
fitness = zeros(NP,1);%存储归一化适应值
gen = 0;

           %%%遗传算法循环%%%
while gen < G
%计算路径长度
    for i = 1:NP
        len(i,1) = D(f(i,n),f(i,1));%最终回到目的地行驶的距离
       for j = 1:(n-1)
        len(i,1) = len(i,1) + D(f(i,j),f(i,j+1));%从j到j+1行驶的距离
       end
    end
maxlen = max(len);
minlen = min(len);

%更新最短路径
rr = find(len==minlen);
R = f(rr(1,1),:);
%计算归一化适应值；将路径长度转为【0 - 1】之间；因为是求最短路径，所以为1-
for i = 1:length(len)
    fitness(i,1) = (1-((len(i,1)-minlen) / (maxlen-minlen+0.001)));%+0.001是为了避免分母为0
end
%选择操作
nn = 0;
for i = 1:NP
    if fitness(i,1) >= rand
        nn = nn + 1;
        F(nn,:) = f(i,:);
    end
end
[aa,bb] = size(F);
while aa < NP
    nnper = randperm(nn);
    A = F(nnper(1),:);%nnper里边的第一个数
    B = F(nnper(2),:);
    %交叉操作
    W = ceil(n/10);%交叉点个数;ceil朝正无穷取整
    p = unidrnd(n-W+1); %随机选择交叉范围，从p 到 p+w
    for i = 1 : W
        x = find(A==B(1,p+i-1));
        y = find(B==A(1,p+i-1));
        temp = A(1,p+i-1);%同一位置交叉
        A(1,p+i-1) = B(1,p+i-1);
        B(1,p+i-1) = temp;
        temp = A(1,x);%同一数值交叉
        A(1,x) = B(1,y);
        B(1,y) = temp;
    end
    %变异操作
    p1 =floor(1+n*rand());%floor朝负无穷取整
    p2 =floor(1+n*rand());
    while p1 == p2
        p1 =floor(1+n*rand());
        p2 =floor(1+n*rand());
    end
    
    tmp = A(p1);
    A(p1) = A(p2);
    A(p2) = tmp;
    
    tmp = B(p1);
    B(p1) = B(p2);
    B(p2) = tmp;
    
    F = [F;A;B];
    [aa,bb] = size(F);  
end 
if aa > NP
    F = F(1:NP,:);%保持种群规模为NP
end
f = F; %更新种群
f(1,:) = R; %保持每代最优个体
clear F;
gen = gen + 1;
Rlength(gen) = minlen;
end
figure(1)
for i = 1 : n-1
    plot([citys(R(i),1),citys(R(i+1),1),citys(R(i),2),citys(R(i+1),2)],'bo-');
    hold on;
end
plot([citys(R(n),1),citys(R(1),1),citys(R(i),2),citys(R(n),2)],'ro-');
title(['优化最短距离',num2str(minlen)]);

figure(2)
plot3([citys(R,1);citys(R(1),1)],...
     [citys(R,2);citys(R(1),2)],...
     [citys(R,3);citys(R(1),3),],'o-');

grid on
for i = 1:size(citys,1)
    text(citys(i,1),citys(i,2),citys(i,3),['   ' num2str(i)]);
end
text(citys(R(1),1),citys(R(1),2),citys(R(1),3),'       起点');
text(citys(R(end),1),citys(R(end),2),citys(R(end),3),'       终点');
set(gca, 'xticklabel', 0 : 5 : 40);
set(gca, 'ytick',0 : 2 : 16, 'ydir','reverse' );
% set(gca, 'ytick', 'reverse' );
xlabel('城市位置横坐标')
ylabel('城市位置纵坐标')
zlabel('城市位置高程坐标')
title(['遗传算法优化路径(最短距离:' num2str(minlen) ')'])

figure(3)
plot(Rlength)
xlabel('迭代次数')
ylabel('目标函数值')
title('遗传算法适应度进化曲线')
    


























